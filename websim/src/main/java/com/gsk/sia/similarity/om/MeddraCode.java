
package com.gsk.sia.similarity.om;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.torque.criteria.Criteria;
import org.apache.torque.om.Persistent;
import org.apache.torque.util.CountHelper;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

/**
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [Wed Jun 10 12:44:01 EDT 2015]
 *
 * You should add additional methods to this class to meet the application
 * requirements. This class will only be generated as long as it does not
 * already exist in the output directory.
 */
public class MeddraCode extends com.gsk.sia.similarity.om.BaseMeddraCode implements Persistent {
	/** Logging */
	private static Log log = LogFactory.getLog(MeddraCode.class);

	/**
	 * Convert to a JSON object
	 * 
	 * @return
	 */
	public com.gsk.sia.similarity.json.om.MeddraCode toJson() {
		try {
			Gson gson = new GsonBuilder().setPrettyPrinting().create();
			com.gsk.sia.similarity.json.om.MeddraCode jsonCode;
			jsonCode = new com.gsk.sia.similarity.json.om.MeddraCode(this);
			return jsonCode;
		} catch (Exception e) {
			return new com.gsk.sia.similarity.json.om.MeddraCode();
		}

	}

	/**
	 * Convert the UMLS AUI into an int
	 * 
	 * @return
	 */
	public int getAuiAsInt() {
		try {
			int i_aui = Integer.parseInt(this.getUmlsAui().substring(1));
			return i_aui;
		} catch (Exception e) {
			return -1;
		}
	}

	/**
	 * Get all of the CUIs from the database
	 * 
	 * @return
	 */
	public static List<String> getAllPTCuis() {
		HashMap<String, Boolean> uniqueCuis = new HashMap<>();
		try {
			// List all products in alpha order
			Criteria criteria = new Criteria();
			criteria.addAscendingOrderByColumn(MeddraCodePeer.MEDDRA_CODE);
			List<MeddraCode> results = (List<MeddraCode>) MeddraCodePeer.doSelect(criteria);
			for (MeddraCode mc : results) {
				// Limit to LLT and PT terms
				if (mc.getCodeId() == 1 || mc.getCodeId() == 2)
					uniqueCuis.put(mc.getUmlsCui(), true);
			}

			// Convert to a list and return
			return new ArrayList<>(uniqueCuis.keySet());

		} catch (Exception e) {
			return new ArrayList<String>();
		}

	}

	public static List<MeddraCode> getAllConditions() {

		try {
			// List all products in alpha order
			Criteria criteria = new Criteria();
			criteria.addAscendingOrderByColumn(MeddraCodePeer.MEDDRA_CODE);
			return (List<MeddraCode>) MeddraCodePeer.doSelect(criteria);
		} catch (Exception e) {
			return new Vector<MeddraCode>();
		}
	}

	public static MeddraCode getMeddraCodeByKey(int pid) {

		try {
			// List all drug abuse options in alpha order
			Criteria criteria = new Criteria();
			criteria.where(MeddraCodePeer.REF_ID, pid);
			return (MeddraCode) MeddraCodePeer.doSelect(criteria).get(0);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Get the TTY
	 * 
	 * @return
	 */
	public String getTty() {
		String tty = "NA";
		try {
			tty = this.getMeddraCodeType().getCodeType();
		} catch (Exception e) {
		}
		return tty;
	}

	/**
	 * Find the preferred term for a MedDRA code, returns itself if it is the
	 * preferred code
	 * 
	 * @return
	 */
	public MeddraCode getPreferredTerm() {
		if (this.isPreferred() == true)
			return this;
		else {
			List<MeddraCode> relatedCodes = this.getSynonyms();
			for (MeddraCode c : relatedCodes) {
				if (c.isPreferred())
					return c;
			}
		}

		return null;
	}

	/**
	 * Get all the synonyms related to this meddra code
	 * 
	 * @return
	 */
	public List<MeddraCode> getSynonyms() {
		// code set
		try {

			Criteria criteria = new Criteria();
			criteria.where(MeddraCodePeer.UMLS_CUI, this.getUmlsCui());
			List<MeddraCode> results = MeddraCodePeer.doSelect(criteria);
			return results;

		} catch (Exception e) {
			log.error("Could not find synonyms for this code: " + this.getMeddraCode());
			return null;
		}
	}

	public boolean isPreferred() {
		try {
			MeddraCodeType tty = this.getMeddraCodeType();
			if (tty.getCodeType().equals("PT"))
				return true;
			else
				return false;
		} catch (Exception e) {
			log.error("Could not find term type: " + e.toString());
			return false;
		}
	}

	public static MeddraCode getMeddraCodeByCode(String code) {
		// code set
		try {

			Criteria criteria = new Criteria();
			criteria.where(MeddraCodePeer.MEDDRA_CODE, code);
			List<MeddraCode> results = MeddraCodePeer.doSelect(criteria);
			if (results.size() == 1) {
				return results.get(0);
			} else {
				for (MeddraCode mc : results) {
					if (mc.getMeddraCodeType().getCodeType().contentEquals("PT"))
						return mc;
				}
			}

			return null;

		} catch (Exception e) {
			log.error("Could not find entry for this code: " + code);
			return null;
		}
	}

	/**
	 * Return meddra codes matching on this CUI
	 * 
	 * @param cui
	 * @return
	 */
	public static List<MeddraCode> getCodesMatchedByCui(String cui) {
		try {
			Criteria criteria = new Criteria();
			criteria.where(MeddraCodePeer.UMLS_CUI, cui);
			return MeddraCodePeer.doSelect(criteria);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Get all of the SOC level terms
	 * 
	 * @return
	 */
	public static List<MeddraCode> getAllSOCs() {

		try {
			// OS = SOC level
			MeddraCodeType tty = MeddraCodeType.getCodeType("OS");
			Criteria criteria = new Criteria();
			criteria.where(MeddraCodePeer.CODE_ID, tty.getRefId());
			return MeddraCodePeer.doSelect(criteria);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Get all of the HLGT level terms
	 * 
	 * @return
	 */
	public static List<MeddraCode> getAllHLGTs() {

		try {
			// HG = High Level Group Terms
			MeddraCodeType tty = MeddraCodeType.getCodeType("HG");
			Criteria criteria = new Criteria();
			criteria.where(MeddraCodePeer.CODE_ID, tty.getRefId());
			return MeddraCodePeer.doSelect(criteria);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Get the PT codes related to this HLGT
	 * 
	 * @return
	 */
	public List<MeddraCode> getFaersHlgtPtCodes(boolean ptOnly) {
		List<MeddraCode> results = new ArrayList<>();
		try {
			if (this.getMeddraCodeType().getCodeType().contentEquals("HG")) {

				// PT Terms
				MeddraCodeType tty = MeddraCodeType.getCodeType("PT");

				// Build query
				Criteria criteria = new Criteria();
				criteria.where(FaersMpgPeer.HLGT_CODE, this.getRefId());
				criteria.addJoin(FaersMpgPeer.PT_CODE, MeddraCodePeer.REF_ID);

				// Restrict to PT only terms?
				if (ptOnly == true) {
					criteria.where(MeddraCodePeer.CODE_ID, tty.getRefId());
				}

				results = MeddraCodePeer.doSelect(criteria);

				// Remove duplicate PT/LLT entries
				HashMap<String, Boolean> dupliateCode = new HashMap<>();
				List<MeddraCode> cleanResults = new ArrayList<>();
				for (MeddraCode mc : results) {
					if (dupliateCode.containsKey(mc.getMeddraCode()) == false) {
						dupliateCode.put(mc.getMeddraCode(), false);
					} else {
						dupliateCode.put(mc.getMeddraCode(), true);
					}
				}

				for (MeddraCode mc : results) {
					if (dupliateCode.get(mc.getMeddraCode()) == false) {
						cleanResults.add(mc);
					} else {
						// Only add the PT type
						if (mc.getMeddraCodeType().getCodeType().contentEquals("PT")) {
							cleanResults.add(mc);
						}
					}
				}

				// Update
				results = cleanResults;

			}
		} catch (Exception e) {
		}
		return results;
	}

	/**
	 * Count the total number of PTs captured by this HLGT
	 * 
	 * @return
	 */
	public int getFaersPtCount() {
		try {
			if (this.getMeddraCodeType().getCodeType().contentEquals("HG")) {

				// PT Terms
				MeddraCodeType tty = MeddraCodeType.getCodeType("PT");

				// Build query
				Criteria criteria = new Criteria();
				criteria.where(FaersMpgPeer.HLGT_CODE, this.getRefId());
				criteria.addJoin(FaersMpgPeer.PT_CODE, MeddraCodePeer.REF_ID);
				criteria.where(MeddraCodePeer.CODE_ID, tty.getRefId());
				CountHelper counter = new CountHelper();
				int count = counter.count(criteria, MeddraCodePeer.REF_ID);
				return count;
			} else {
				return 0;
			}
		} catch (Exception e) {
			return 0;
		}
	}

	/**
	 * Count the total number of LLTs captured by this HLGT
	 * 
	 * @return
	 */
	public int getFaersLltCount() {
		try {
			if (this.getMeddraCodeType().getCodeType().contentEquals("HG")) {

				// PT Terms
				MeddraCodeType tty = MeddraCodeType.getCodeType("LLT");

				// Build query
				Criteria criteria = new Criteria();
				criteria.where(FaersMpgPeer.HLGT_CODE, this.getRefId());
				criteria.addJoin(FaersMpgPeer.PT_CODE, MeddraCodePeer.REF_ID);
				criteria.where(MeddraCodePeer.CODE_ID, tty.getRefId());
				CountHelper counter = new CountHelper();
				int count = counter.count(criteria, MeddraCodePeer.REF_ID);
				return count;
			} else {
				return 0;
			}
		} catch (Exception e) {
			return 0;
		}
	}

	/**
	 * Count the total number of PTs and LLTs captured by this HLGT
	 * 
	 * @return
	 */
	public int getFaersTotalCount() {
		return (this.getFaersPtCount() + this.getFaersLltCount());
	}

	/**
	 * Get the parents of this code
	 * 
	 * @return
	 */
	public List<MeddraCode> getParents() {
		try {

			Criteria criteria = new Criteria();
			criteria.where(MeddraHierarchyPeer.CHILD_CODE, this.getRefId());
			criteria.addJoin(MeddraHierarchyPeer.PARENT_CODE, MeddraCodePeer.REF_ID);
			return MeddraCodePeer.doSelect(criteria);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Get the children of this code
	 * 
	 * @return
	 */
	public List<MeddraCode> getChildren() {
		try {

			Criteria criteria = new Criteria();
			criteria.where(MeddraHierarchyPeer.PARENT_CODE, this.getRefId());
			criteria.addJoin(MeddraHierarchyPeer.CHILD_CODE, MeddraCodePeer.REF_ID);
			return MeddraCodePeer.doSelect(criteria);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Restrict to children that have context = 1
	 * 
	 * @return
	 */
	public List<MeddraCode> getPrimaryChildren() {
		try {

			Criteria criteria = new Criteria();
			criteria.where(MeddraHierarchyPeer.PARENT_CODE, this.getRefId());
			criteria.where(MeddraHierarchyPeer.CONTEXT, 1);
			criteria.addJoin(MeddraHierarchyPeer.CHILD_CODE, MeddraCodePeer.REF_ID);
			return MeddraCodePeer.doSelect(criteria);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Count number of PT children captured by this code
	 * 
	 * @return
	 */
	public int getPtCount() {
		try {
			return this.getPtChildren().size();
		} catch (Exception e) {
			return 0;
		}
	}

	/**
	 * This will only return children from an HLT or HLGT
	 * 
	 * @return
	 */
	public List<MeddraCode> getPtChildren() {
		try {
			MeddraCodeType tty = this.getMeddraCodeType();
			if (tty.getCodeType().contentEquals("HG")) {
				List<MeddraCode> hlts = this.getChildren();
				HashMap<Integer, MeddraCode> uniquePts = new HashMap<>();
				for (MeddraCode hlt : hlts) {
					List<MeddraCode> children = hlt.getChildren();
					for (MeddraCode child : children) {
						uniquePts.put(child.getAuiAsInt(), child);
					}
				}

				// Convert to a list
				List<MeddraCode> ptTerms = new ArrayList<>();
				for (int aui : uniquePts.keySet())
					ptTerms.add(uniquePts.get(aui));

				return ptTerms;
			}

			// HLT - Just return all the children pointing to this HLT
			if (tty.getCodeType().contentEquals("HT")) {
				return this.getChildren();
			}

			// Invalid call
			return null;

		} catch (Exception e) {
			return null;
		}

	}

	/**
	 * Count number of PT children captured by this code
	 * 
	 * @return
	 */
	public int getPrimaryPtCount() {
		try {
			return this.getPrimaryPtChildren().size();
		} catch (Exception e) {
			return 0;
		}
	}

	/**
	 * This will only return children from an HLT or HLGT
	 * 
	 * @return
	 */
	public List<MeddraCode> getPrimaryPtChildren() {
		try {
			MeddraCodeType tty = this.getMeddraCodeType();
			if (tty.getCodeType().contentEquals("HG")) {
				List<MeddraCode> hlts = this.getPrimaryChildren();
				HashMap<Integer, MeddraCode> uniquePts = new HashMap<>();
				for (MeddraCode hlt : hlts) {
					List<MeddraCode> children = hlt.getPrimaryChildren();
					for (MeddraCode child : children) {
						uniquePts.put(child.getAuiAsInt(), child);
					}
				}

				// Convert to a list
				List<MeddraCode> ptTerms = new ArrayList<>();
				for (int aui : uniquePts.keySet())
					ptTerms.add(uniquePts.get(aui));

				return ptTerms;
			}

			// HLT - Just return all the children pointing to this HLT
			if (tty.getCodeType().contentEquals("HT")) {
				return this.getPrimaryChildren();
			}

			// Invalid call
			return null;

		} catch (Exception e) {
			return null;
		}

	}

	/**
	 * Get the PT code mapped to this code
	 * 
	 * @return
	 */
	public MeddraCode getMappedPTCode() {

		try {
			// List all products in alpha order
			Criteria criteria = new Criteria();
			criteria.where(MeddraLltPtMapPeer.LLT_CODE, this.getRefId());
			criteria.addJoin(MeddraLltPtMapPeer.PT_CODE, MeddraCodePeer.REF_ID);
			MeddraCode ptCode = MeddraCodePeer.doSelectSingleRecord(criteria);
			return ptCode;

		} catch (Exception e) {

		}

		return null;
	}

	/**
	 * Get the preferred HLGT for this code
	 * 
	 * @return
	 */
	public MeddraCode getPreferredHlgt() {
		try {
			// First find the HLGT code
			Criteria criteria = new Criteria();
			criteria.where(FaersMpgPeer.PT_CODE, this.getRefId());
			criteria.where(MeddraCodePeer.REF_ID, FaersMpgPeer.HLGT_CODE);
			MeddraCode hlgtCode = MeddraCodePeer.doSelectSingleRecord(criteria);
			return hlgtCode;
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Get a list of all codes that map to the same HLGT
	 * 
	 * @return
	 */
	public List<MeddraCode> getRelatedHlgtCodes() {
		try {
			// First find the HLGT code
			MeddraCode hlgtCode = this.getPreferredHlgt();

			// List all products in alpha order
			Criteria criteria = new Criteria();
			criteria.where(FaersMpgPeer.HLGT_CODE, hlgtCode.getRefId());
			criteria.addJoin(FaersMpgPeer.PT_CODE, MeddraCodePeer.REF_ID);
			List<MeddraCode> relatedCodes = MeddraCodePeer.doSelect(criteria);
			return relatedCodes;

		} catch (Exception e) {

		}
		return null;
	}

	/**
	 * Get the preferred HLT for this code
	 * 
	 * @return
	 */
	public MeddraCode getPreferredHlt() {
		try {
			// First find the HLGT code
			Criteria criteria = new Criteria();
			criteria.where(FaersMphPeer.PT_CODE, this.getRefId());
			criteria.where(MeddraCodePeer.REF_ID, FaersMphPeer.HLT_CODE);
			MeddraCode hltCode = MeddraCodePeer.doSelectSingleRecord(criteria);
			return hltCode;
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Get a list of all codes that map to the same HLT
	 * 
	 * @return
	 */
	public List<MeddraCode> getRelatedHltCodes() {
		try {
			// First find the HLGT code
			MeddraCode hltCode = this.getPreferredHlt();

			// List all products in alpha order
			Criteria criteria = new Criteria();
			criteria.where(FaersMphPeer.HLT_CODE, hltCode.getRefId());
			criteria.addJoin(FaersMphPeer.PT_CODE, MeddraCodePeer.REF_ID);
			List<MeddraCode> relatedCodes = MeddraCodePeer.doSelect(criteria);
			return relatedCodes;

		} catch (Exception e) {

		}
		return null;
	}

	/**
	 * Support method to find codes related by SMQ
	 * @param scope
	 * @param ptOnly
	 * @return
	 */
	public List<MeddraCode> getCodesRelatedBySMQ(String scope, boolean ptOnly) {

		try {
			// Narrow or broad scope?
			boolean isBroad = true;
			if (scope.contentEquals("narrow")) {
				isBroad = false;
			}
			List<MeddraSmq> smqs = MeddraSmq.getAllSmqs();
			for (MeddraSmq smq : smqs) {

				// Test if this is the SMQ scope we want to test
				boolean validSmq = true;
				if (isBroad == true) {
					if (smq.isBroad() == false) {
						validSmq = false;
					}
				}

				List<MeddraCode> allCodes = smq.getMeddraCodes(ptOnly);
				boolean containsCode = false;
				if (validSmq) {

					for (MeddraCode mc : allCodes) {
						if (mc.getAuiAsInt() == this.getAuiAsInt())
							containsCode = true;
					}
				}

				// Return all codes except this code matching by SMQ
				if (containsCode == true) {
					List<MeddraCode> results = new ArrayList<>();
					for (MeddraCode mc : allCodes) {
						if (mc.getAuiAsInt() != this.getAuiAsInt()) {
							results.add(mc);
						}
					}
					return results;
				}
			}
		} catch (Exception e) {

		}
		return null;
	}

}
